---
# Configure the MySQL server for replication as a primary or replica


- name: replication | check for the mysql_repl_password variable
  fail:
    msg: "mysql_repl_password has not been defined."
  when: mysql_repl_password is not defined
  tags:
    - mysql_replication_setup
    - mysql_repair_replication


##
# Configure the server for replication
##
- name: replication | setup replication options
  ansible.builtin.template:
    src: replication.cnf.j2
    dest: /etc/mysql/conf.d/replication.cnf
    owner: root
    group: root
    mode: 0644
  register: _mysql_replication_conf
  notify: restart mysql
  become: yes
  tags:
    - mysql_replication_setup

- name: create the log directory
  ansible.builtin.file:
    path: "{{ mysql_logdir }}"
    state: directory
    owner: mysql
    group: mysql
    mode: 0755
  become: yes
  tags:
    - mysql_replication_setup

- name: replication | restart MySQL if replication setup
  ansible.builtin.service:
    name: "{{ mysql_service }}"
    state: restarted
  become: yes
  when: _mysql_replication_conf.changed
  tags:
    - mysql_replication_setup


##
# Configure the primary
##
- name: replication | setup replication user
  community.mysql.mysql_user:
    name: "{{ mysql_repl_user }}"
    password: "{{ mysql_repl_password }}"
    priv: "*.*:REPLICATION SLAVE"
    host: "{{ hostvars[item].ansible_host }}"
    state: present
    login_unix_socket: "{{ mysql_socket }}"
  loop: "{{ groups.datareplica }}"
  loop_control:
    label: "{{ item }}"
  become: yes
  when: mysql_repl_primary|bool
  notify: restart mysql
  tags:
    - mysql_replication_setup


##
# Determine if the replica is already configured
##
- name: replication | determine if replica is already configured
  community.mysql.mysql_replication:
    mode: getslave
    login_unix_socket: "{{ mysql_socket }}"
  ignore_errors: true
  register: _mysql_replica_status
  become: yes
  when: mysql_repl_replica|bool
  tags:
    - mysql_replication_setup

- name: replication | fake the replica's status when repairing replication
  ansible.builtin.set_fact:
    _mysql_replica_status:
      failed: true
  when: mysql_repl_replica|bool and _mysql_replica_status is not defined
  tags:
    - mysql_repair_replication


##
# Initially configure a new replica
##
- name: replication | stop replica for new configuration
  community.mysql.mysql_replication:
    mode: stopslave
    login_unix_socket: "{{ mysql_socket }}"
  become: yes
  when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
  tags:
    - mysql_replication_setup
    - mysql_repair_replication

- name: replication | reset the replication primary
  community.mysql.mysql_replication:
    mode: resetmaster
    login_unix_socket: "{{ mysql_socket }}"
  become: yes
  delegate_to: "{{ mysql_repl_primary_inventory_name }}"
  when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
  tags:
    - mysql_replication_setup
    - mysql_repair_replication

### NOTE: this likely does not do what we think/hope it does
# - name: replication | flush and lock the tables on the primary
#   ansible.builtin.command:
#     argv:
#       - mysql
#       - "-e"
#       - "'FLUSH TABLES WITH READ LOCK;'"
#   delegate_to: "{{ mysql_repl_primary_inventory_name }}"
#   become: yes
#   when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
#   tags:
#     - mysql_replication_setup
#     - mysql_repair_replication

- name: replication | dump the data from the primary
  community.mysql.mysql_db:
    state: dump
    name: all
    master_data: 1
    target: "/home/{{ devops_user|default(ansible_user) }}/mysql-replication-dump.sql"
    login_unix_socket: "{{ mysql_socket }}"
  delegate_to: "{{ mysql_repl_primary_inventory_name }}"
  become: yes
  when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
  tags:
    - mysql_replication_setup
    - mysql_repair_replication

- name: replication | download the dumped data
  ansible.builtin.fetch:
    src: "/home/{{ devops_user|default(ansible_user) }}/mysql-replication-dump.sql"
    dest: "{{ playbook_tmp|default('./tmp') }}/"
    flat: yes
  delegate_to: "{{ mysql_repl_primary_inventory_name }}"
  when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
  tags:
    - mysql_replication_setup
    - mysql_repair_replication

- name: replication | upload the dumped data
  ansible.builtin.copy:
    src: "{{ playbook_tmp|default('./tmp') }}/mysql-replication-dump.sql"
    dest: "/home/{{ devops_user|default(ansible_user) }}/mysql-replication-dump.sql"
  when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
  tags:
    - mysql_replication_setup
    - mysql_repair_replication

- name: replication | load the dumped data
  community.mysql.mysql_db:
    state: import
    name: all
    target: "/home/{{ devops_user|default(ansible_user) }}/mysql-replication-dump.sql"
    login_unix_socket: "{{ mysql_socket }}"
  become: yes
  when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
  tags:
    - mysql_replication_setup
    - mysql_repair_replication

- name: replication | remove the dumped data from the primary
  ansible.builtin.file:
    path: "/home/{{ devops_user|default(ansible_user) }}/mysql-replication-dump.sql"
    state: absent
  delegate_to: "{{ mysql_repl_primary_inventory_name }}"
  when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
  tags:
    - mysql_replication_setup
    - mysql_repair_replication

- name: replication | remove the dumped data from the replica
  ansible.builtin.file:
    path: "/home/{{ devops_user|default(ansible_user) }}/mysql-replication-dump.sql"
    state: absent
  when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
  tags:
    - mysql_replication_setup
    - mysql_repair_replication

- name: replication | remove the dumped data from the controller
  ansible.builtin.file:
    path: "{{ playbook_tmp|default('./tmp') }}/mysql-replication-dump.sql"
    state: absent
  delegate_to: 127.0.0.1
  when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
  tags:
    - mysql_replication_setup
    - mysql_repair_replication

- name: replication | reset the replica
  community.mysql.mysql_replication:
    mode: resetslave
    login_unix_socket: "{{ mysql_socket }}"
  become: yes
  when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
  tags:
    - mysql_replication_setup
    - mysql_repair_replication

- name: replication | configure replica to replicate with the primary
  community.mysql.mysql_replication:
    mode: changemaster
    master_host: "{{ mysql_repl_primary_ip }}"
    master_port: "{{ mysql_repl_primary_port }}"
    master_user: "{{ mysql_repl_user }}"
    master_password: "{{ mysql_repl_password }}"
    master_ssl: "{% if mysql_force_tls|bool %}yes{% else %}no{% endif %}"
    login_unix_socket: "{{ mysql_socket }}"
  notify: restart mysql
  become: yes
  when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
  tags:
    - mysql_replication_setup
    - mysql_repair_replication


##
# Ensure the replica is started
##
- name: replication | start replica
  community.mysql.mysql_replication:
    mode: startslave
    login_unix_socket: "{{ mysql_socket }}"
  become: yes
  when: mysql_repl_replica|bool
  tags:
    - mysql_replication_setup
    - mysql_repair_replication


##
# Unlock the tables on the primary
##
### NOTE: this likely does not do what we think/hope it does
# - name: replication | unlock the tables on the master
#   ansible.builtin.command:
#     argv:
#       - mysql
#       - "-e"
#       - "'UNLOCK TABLES;'"
#   delegate_to: "{{ mysql_repl_primary_inventory_name }}"
#   become: yes
#   when: "(not _mysql_replica_status.Is_Slave|default(false)|bool) and mysql_repl_replica|bool"
#   tags:
#     - mysql_replication_setup
#     - mysql_repair_replication


##
# Install/configure the MySQL replication watchdog
##
- name: replication | setup MySQL replication watchdog
  block:
    - name: replication | create watchdog script directory
      ansible.builtin.file:
        path: /opt/mysqlwatch
        state: directory
        owner: "{{ devops_user|default(ansible_user) }}"
        group: "{{ devops_group|default('admin') }}"
        mode: 0775
      become: yes

    - name: replication | install the watchdog script
      ansible.builtin.git:
        repo: "https://github.com/paulrentschler/mysqlwatch.git"
        dest: /opt/mysqlwatch
        version: master

    - name: replication | schedule the watchdog script
      ansible.builtin.template:
        src: watch.cron.j2
        dest: /etc/cron.d/mysqlwatch
        owner: root
        group: root
        mode: 0644
      become: yes
  when: mysql_repl_watchdog|bool
  tags:
    - mysql_replication_setup
